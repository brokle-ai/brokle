// Package main provides database migration tool for both PostgreSQL and ClickHouse.
//
// This is a production-ready migration CLI with comprehensive safety features,
// interactive confirmations for destructive operations, and full support for
// both PostgreSQL and ClickHouse databases.
//
// Usage Examples:
//   go run cmd/migrate/main.go up                    # Run all pending migrations
//   go run cmd/migrate/main.go down                  # Rollback 1 migration (with confirmation)
//   go run cmd/migrate/main.go down -steps 5         # Rollback 5 migrations (with confirmation)
//   go run cmd/migrate/main.go -db postgres up       # Run PostgreSQL migrations only
//   go run cmd/migrate/main.go -db clickhouse up     # Run ClickHouse migrations only
//   go run cmd/migrate/main.go status                # Show migration status
//   go run cmd/migrate/main.go goto -version 5       # Migrate to specific version (with confirmation)
//   go run cmd/migrate/main.go force -version 3      # Force version (with confirmation)
//   go run cmd/migrate/main.go drop                  # Drop all tables (with confirmation)
//   go run cmd/migrate/main.go steps -steps 2        # Run 2 steps forward
//   go run cmd/migrate/main.go steps -steps -1       # Run 1 step backward
//   go run cmd/migrate/main.go info                  # Show detailed migration information
//   go run cmd/migrate/main.go create -name "add_users" -db postgres  # Create new migration
package main

import (
	"bufio"
	"context"
	"flag"
	"fmt"
	"log"
	"os"
	"strings"

	"brokle/internal/config"
	"brokle/internal/migration"
	"brokle/internal/seeder"
)

// MigrateFlags holds all parsed command-line flags
type MigrateFlags struct {
	Database    string
	Steps       int
	Version     int
	Name        string
	DryRun      bool
	Environment string
	Reset       bool
	Verbose     bool
}

// parseFlags parses flags from arguments, supporting flags before or after the command
func parseFlags(args []string) (*MigrateFlags, string, error) {
	// Check for help first
	for _, arg := range args {
		if arg == "-h" || arg == "--help" || arg == "help" {
			return nil, "help", nil
		}
	}

	if len(args) == 0 {
		return nil, "", fmt.Errorf("no command specified")
	}

	// Create a new flag set for parsing
	fs := flag.NewFlagSet("migrate", flag.ContinueOnError)
	fs.SetOutput(os.Stderr)

	// Define all flags
	flags := &MigrateFlags{}
	fs.StringVar(&flags.Database, "db", "all", "Database to migrate: all, postgres, clickhouse")
	fs.IntVar(&flags.Steps, "steps", 0, "Number of migration steps (0 = all)")
	fs.IntVar(&flags.Version, "version", 0, "Target version for goto/force commands")
	fs.StringVar(&flags.Name, "name", "", "Migration name for create command")
	fs.BoolVar(&flags.DryRun, "dry-run", false, "Show what would be migrated without executing")
	fs.StringVar(&flags.Environment, "env", "development", "Environment for seeding: development, demo, test")
	fs.BoolVar(&flags.Reset, "reset", false, "Reset existing data before seeding")
	fs.BoolVar(&flags.Verbose, "verbose", false, "Verbose output for seeding")

	// Parse all arguments - fs.Parse will stop at the first non-flag arg
	if err := fs.Parse(args); err != nil {
		return nil, "", err
	}

	// The command is the first remaining argument after flag parsing
	remainingArgs := fs.Args()
	if len(remainingArgs) == 0 {
		return nil, "", fmt.Errorf("no command specified")
	}

	command := remainingArgs[0]

	// If there are more args after the command, they might be additional flags
	// Parse them as well
	if len(remainingArgs) > 1 {
		if err := fs.Parse(remainingArgs[1:]); err != nil {
			return nil, "", err
		}
	}

	return flags, command, nil
}

func main() {
	// Parse flags and extract command (supports flags before or after command)
	flags, command, err := parseFlags(os.Args[1:])
	if err != nil {
		log.Fatalf("Error parsing flags: %v", err)
	}

	// Handle help command
	if command == "help" || command == "" {
		printUsage()
		return
	}

	// Load configuration
	cfg, err := config.Load()
	if err != nil {
		log.Fatalf("Failed to load configuration: %v", err)
	}

	// Parse database selection
	databases, err := parseDatabaseSelection(flags.Database)
	if err != nil {
		log.Fatalf("Invalid database selection: %v", err)
	}

	// Initialize migration manager with selected databases
	manager, err := migration.NewManagerWithDatabases(cfg, databases)
	if err != nil {
		log.Fatalf("Failed to initialize migration manager: %v", err)
	}
	defer manager.Shutdown()

	ctx := context.Background()

	// Handle different commands
	switch command {
	case "up":
		if err := runMigrations(ctx, manager, flags.Database, "up", flags.Steps, flags.DryRun); err != nil {
			log.Fatalf("Migration failed: %v", err)
		}
		fmt.Println("‚úÖ Migrations completed successfully")

	case "down":
		// Default to 1 step if no -steps flag provided
		downSteps := flags.Steps
		if downSteps == 0 {
			downSteps = 1
		}

		if !confirmDestructiveOperation(fmt.Sprintf("rollback %d migration(s)", downSteps)) {
			fmt.Println("Operation cancelled")
			return
		}
		if err := runMigrations(ctx, manager, flags.Database, "down", downSteps, flags.DryRun); err != nil {
			log.Fatalf("Migration failed: %v", err)
		}
		fmt.Println("‚úÖ Rollback completed successfully")

	case "status":
		if err := showStatus(ctx, manager, flags.Database); err != nil {
			log.Fatalf("Failed to show status: %v", err)
		}

	case "goto":
		if flags.Version == 0 {
			log.Fatal("Version must be specified for goto command (use -version flag)")
		}
		if !confirmDestructiveOperation(fmt.Sprintf("migrate to version %d", flags.Version)) {
			fmt.Println("Operation cancelled")
			return
		}
		if err := gotoVersion(manager, flags.Database, uint(flags.Version)); err != nil {
			log.Fatalf("Failed to migrate to version %d: %v", flags.Version, err)
		}
		fmt.Printf("‚úÖ Migrated to version %d successfully\n", flags.Version)

	case "force":
		if flags.Version == 0 {
			log.Fatal("Version must be specified for force command (use -version flag)")
		}
		if !confirmDestructiveOperation(fmt.Sprintf("FORCE migration to version %d (DANGEROUS)", flags.Version)) {
			fmt.Println("Operation cancelled")
			return
		}
		if err := forceVersion(manager, flags.Database, flags.Version); err != nil {
			log.Fatalf("Failed to force migration to version %d: %v", flags.Version, err)
		}
		fmt.Printf("‚ö†Ô∏è  Forced migration to version %d successfully\n", flags.Version)

	case "drop":
		if !confirmDestructiveOperation("DROP ALL TABLES (PERMANENT DATA LOSS)") {
			fmt.Println("Operation cancelled")
			return
		}
		if err := dropTables(manager, flags.Database); err != nil {
			log.Fatalf("Failed to drop tables: %v", err)
		}
		fmt.Println("‚ö†Ô∏è  Tables dropped successfully")

	case "steps":
		if flags.Steps == 0 {
			log.Fatal("Steps must be specified for steps command (use -steps flag)")
		}
		if flags.Steps < 0 && !confirmDestructiveOperation(fmt.Sprintf("rollback %d migration steps", -flags.Steps)) {
			fmt.Println("Operation cancelled")
			return
		}
		if err := runSteps(manager, flags.Database, flags.Steps); err != nil {
			log.Fatalf("Failed to run %d migration steps: %v", flags.Steps, err)
		}
		fmt.Printf("‚úÖ Ran %d migration steps successfully\n", flags.Steps)

	case "info":
		if err := showDetailedInfo(manager); err != nil {
			log.Fatalf("Failed to get migration info: %v", err)
		}

	case "create":
		if flags.Name == "" {
			log.Fatal("Migration name is required for create command (use -name flag)")
		}
		if err := createMigration(manager, flags.Database, flags.Name); err != nil {
			log.Fatalf("Failed to create migration: %v", err)
		}

	case "seed":
		if err := runSeeding(ctx, cfg, flags.Environment, flags.Reset, flags.DryRun, flags.Verbose); err != nil {
			log.Fatalf("Seeding failed: %v", err)
		}
		fmt.Printf("‚úÖ Seeding completed successfully with environment: %s\n", flags.Environment)

	default:
		fmt.Printf("‚ùå Unknown command: %s\n", command)
		printUsage()
		os.Exit(1)
	}
}

// confirmDestructiveOperation prompts user for confirmation on dangerous operations
func confirmDestructiveOperation(operation string) bool {
	fmt.Printf("‚ö†Ô∏è  DANGER: About to %s.\n", operation)
	fmt.Printf("This action cannot be undone and may result in data loss.\n")
	fmt.Print("Type 'yes' to confirm (anything else will cancel): ")
	
	reader := bufio.NewReader(os.Stdin)
	response, err := reader.ReadString('\n')
	if err != nil {
		return false
	}
	
	response = strings.TrimSpace(strings.ToLower(response))
	return response == "yes"
}

func runMigrations(ctx context.Context, manager *migration.Manager, database, direction string, steps int, dryRun bool) error {
	if dryRun {
		fmt.Printf("üîç DRY RUN: Would run %s migrations for %s", direction, database)
		if steps > 0 {
			fmt.Printf(" (%d steps)", steps)
		}
		fmt.Println()
	}

	switch database {
	case "postgres":
		if direction == "up" {
			return manager.MigratePostgresUp(ctx, steps, dryRun)
		}
		return manager.MigratePostgresDown(ctx, steps, dryRun)
	case "clickhouse":
		if direction == "up" {
			return manager.MigrateClickHouseUp(ctx, steps, dryRun)
		}
		return manager.MigrateClickHouseDown(ctx, steps, dryRun)
	case "all":
		if direction == "up" {
			if err := manager.MigratePostgresUp(ctx, steps, dryRun); err != nil {
				return fmt.Errorf("postgres migration failed: %w", err)
			}
			return manager.MigrateClickHouseUp(ctx, steps, dryRun)
		}
		// For down migrations, reverse order (ClickHouse first, then PostgreSQL)
		if err := manager.MigrateClickHouseDown(ctx, steps, dryRun); err != nil {
			return fmt.Errorf("clickhouse migration failed: %w", err)
		}
		return manager.MigratePostgresDown(ctx, steps, dryRun)
	default:
		return fmt.Errorf("unknown database: %s", database)
	}
}

func showStatus(ctx context.Context, manager *migration.Manager, database string) error {
	switch database {
	case "postgres":
		return manager.ShowPostgresStatus(ctx)
	case "clickhouse":
		return manager.ShowClickHouseStatus(ctx)
	case "all":
		fmt.Println("üêò PostgreSQL Migration Status:")
		if err := manager.ShowPostgresStatus(ctx); err != nil {
			fmt.Printf("‚ùå Error getting PostgreSQL status: %v\n", err)
		}
		fmt.Println()
		
		fmt.Println("üè† ClickHouse Migration Status:")
		if err := manager.ShowClickHouseStatus(ctx); err != nil {
			fmt.Printf("‚ùå Error getting ClickHouse status: %v\n", err)
		}
		
		// Show overall health
		fmt.Println()
		info, err := manager.GetMigrationInfo()
		if err != nil {
			fmt.Printf("‚ùå Error getting overall status: %v\n", err)
		} else {
			switch info.Overall {
			case "healthy":
				fmt.Println("Overall Status: üü¢ HEALTHY")
			case "dirty":
				fmt.Println("Overall Status: üü° DIRTY (requires attention)")
			case "error":
				fmt.Println("Overall Status: üî¥ ERROR")
			default:
				fmt.Printf("Overall Status: ‚ùì %s\n", info.Overall)
			}
		}
		return nil
	default:
		return fmt.Errorf("unknown database: %s", database)
	}
}

func gotoVersion(manager *migration.Manager, database string, version uint) error {
	switch database {
	case "postgres":
		return manager.GotoPostgres(version)
	case "clickhouse":
		return manager.GotoClickHouse(version)
	case "all":
		if err := manager.GotoPostgres(version); err != nil {
			return fmt.Errorf("postgres goto failed: %w", err)
		}
		return manager.GotoClickHouse(version)
	default:
		return fmt.Errorf("unknown database: %s", database)
	}
}

func forceVersion(manager *migration.Manager, database string, version int) error {
	switch database {
	case "postgres":
		return manager.ForcePostgres(version)
	case "clickhouse":
		return manager.ForceClickHouse(version)
	case "all":
		if err := manager.ForcePostgres(version); err != nil {
			return fmt.Errorf("postgres force failed: %w", err)
		}
		return manager.ForceClickHouse(version)
	default:
		return fmt.Errorf("unknown database: %s", database)
	}
}

func dropTables(manager *migration.Manager, database string) error {
	switch database {
	case "postgres":
		return manager.DropPostgres()
	case "clickhouse":
		return manager.DropClickHouse()
	case "all":
		if err := manager.DropClickHouse(); err != nil {
			return fmt.Errorf("clickhouse drop failed: %w", err)
		}
		return manager.DropPostgres()
	default:
		return fmt.Errorf("unknown database: %s", database)
	}
}

func runSteps(manager *migration.Manager, database string, steps int) error {
	switch database {
	case "postgres":
		return manager.StepsPostgres(steps)
	case "clickhouse":
		return manager.StepsClickHouse(steps)
	case "all":
		if err := manager.StepsPostgres(steps); err != nil {
			return fmt.Errorf("postgres steps failed: %w", err)
		}
		return manager.StepsClickHouse(steps)
	default:
		return fmt.Errorf("unknown database: %s", database)
	}
}

func showDetailedInfo(manager *migration.Manager) error {
	info, err := manager.GetMigrationInfo()
	if err != nil {
		return err
	}
	
	fmt.Println("üìä Detailed Migration Information")
	fmt.Println(strings.Repeat("=", 50))
	
	fmt.Println("\nüêò PostgreSQL:")
	fmt.Printf("  Status: %s\n", getStatusIcon(info.Postgres.Status))
	fmt.Printf("  Current Version: %d\n", info.Postgres.CurrentVersion)
	fmt.Printf("  Dirty State: %v\n", info.Postgres.IsDirty)
	fmt.Printf("  Migrations Path: %s\n", info.Postgres.MigrationsPath)
	if info.Postgres.Error != "" {
		fmt.Printf("  Error: %s\n", info.Postgres.Error)
	}
	
	fmt.Println("\nüè† ClickHouse:")
	fmt.Printf("  Status: %s\n", getStatusIcon(info.ClickHouse.Status))
	fmt.Printf("  Current Version: %d\n", info.ClickHouse.CurrentVersion)
	fmt.Printf("  Dirty State: %v\n", info.ClickHouse.IsDirty)
	fmt.Printf("  Migrations Path: %s\n", info.ClickHouse.MigrationsPath)
	if info.ClickHouse.Error != "" {
		fmt.Printf("  Error: %s\n", info.ClickHouse.Error)
	}
	
	fmt.Printf("\nüåê Overall Status: %s\n", getStatusIcon(info.Overall))
	
	return nil
}

func getStatusIcon(status string) string {
	switch status {
	case "healthy":
		return "üü¢ HEALTHY"
	case "dirty":
		return "üü° DIRTY"
	case "error":
		return "üî¥ ERROR"
	default:
		return "‚ùì " + strings.ToUpper(status)
	}
}

func createMigration(manager *migration.Manager, database, name string) error {
	switch database {
	case "postgres":
		return manager.CreatePostgresMigration(name)
	case "clickhouse":
		return manager.CreateClickHouseMigration(name)
	case "all":
		fmt.Println("Creating migrations for both databases...")
		if err := manager.CreatePostgresMigration(name); err != nil {
			return fmt.Errorf("failed to create postgres migration: %w", err)
		}
		return manager.CreateClickHouseMigration(name)
	default:
		return fmt.Errorf("unknown database: %s", database)
	}
}

// parseDatabaseSelection converts database flag string to DatabaseType slice
func parseDatabaseSelection(database string) ([]migration.DatabaseType, error) {
	switch database {
	case "postgres":
		return []migration.DatabaseType{migration.PostgresDB}, nil
	case "clickhouse":
		return []migration.DatabaseType{migration.ClickHouseDB}, nil
	case "all":
		return []migration.DatabaseType{migration.PostgresDB, migration.ClickHouseDB}, nil
	default:
		return nil, fmt.Errorf("unknown database: %s (valid options: postgres, clickhouse, all)", database)
	}
}

func printUsage() {
	fmt.Println("üöÄ Brokle Migration Tool - Production Database Migration & Seeding CLI")
	fmt.Println()
	fmt.Println("USAGE:")
	fmt.Println("  migrate <command> [flags]")
	fmt.Println()
	fmt.Println("COMMANDS:")
	fmt.Println("  up                    Run all pending migrations")
	fmt.Println("  down                  Rollback 1 migration (use -steps for more)")
	fmt.Println("  status                Show migration status for all databases")
	fmt.Println("  goto -version N       Migrate to specific version (with confirmation)")
	fmt.Println("  force -version N      Force version without migration (DANGEROUS)")
	fmt.Println("  drop                  Drop all tables (DANGEROUS)")
	fmt.Println("  steps -steps N        Run N migration steps (negative for rollback)")
	fmt.Println("  info                  Show detailed migration information")
	fmt.Println("  create -name NAME     Create new migration files")
	fmt.Println("  seed                  Seed database with test data")
	fmt.Println()
	fmt.Println("FLAGS:")
	fmt.Println("  -db string           Database to target: all, postgres, clickhouse (default: all)")
	fmt.Println("  -steps int           Number of migration steps")
	fmt.Println("  -version int         Target version for goto/force commands")
	fmt.Println("  -name string         Migration name for create command")
	fmt.Println("  -dry-run             Show what would happen without executing")
	fmt.Println("  -env string          Seeding environment: development, demo, test (default: development)")
	fmt.Println("  -reset               Reset existing data before seeding (DANGEROUS)")
	fmt.Println("  -verbose             Verbose output for seeding operations")
	fmt.Println()
	fmt.Println("EXAMPLES:")
	fmt.Println("  migrate up                              # Run all pending migrations")
	fmt.Println("  migrate status -db postgres             # Show PostgreSQL status only")
	fmt.Println("  migrate status -db clickhouse           # Show ClickHouse status only")
	fmt.Println("  migrate up -db postgres                 # Run PostgreSQL migrations only")
	fmt.Println("  migrate down                            # Rollback 1 migration")
	fmt.Println("  migrate down -steps 5                   # Rollback 5 migrations")
	fmt.Println("  migrate down -db postgres -steps 3      # Rollback 3 PostgreSQL migrations")
	fmt.Println("  migrate goto -version 5                 # Go to version 5 with confirmation")
	fmt.Println("  migrate steps -steps 2                  # Run 2 migration steps")
	fmt.Println("  migrate create -name 'add_users'        # Create new migration")
	fmt.Println("  migrate info                            # Show detailed information")
	fmt.Println("  migrate up -dry-run                     # Preview migrations")
	fmt.Println("  migrate seed                            # Seed with development data")
	fmt.Println("  migrate seed -env demo                  # Seed with demo data")
	fmt.Println("  migrate seed -env test -reset -verbose  # Reset and seed with verbose output")
	fmt.Println()
	fmt.Println("NOTE:")
	fmt.Println("  Flags can be placed before or after the command:")
	fmt.Println("  migrate status -db postgres    (recommended)")
	fmt.Println("  migrate -db postgres status    (also works)")
	fmt.Println()
	fmt.Println("SAFETY:")
	fmt.Println("  üõ°Ô∏è  Destructive operations require explicit 'yes' confirmation")
	fmt.Println("  üîç Use -dry-run to preview changes safely")
	fmt.Println("  üìä Check 'status' and 'info' before running migrations")
	fmt.Println("  üå± Use 'seed' to populate database with test data")
}

// runSeeding handles database seeding operations
func runSeeding(ctx context.Context, cfg *config.Config, environment string, reset, dryRun, verbose bool) error {
	// Initialize seeder manager
	manager, err := seeder.NewManager(cfg)
	if err != nil {
		return fmt.Errorf("failed to initialize seeder manager: %w", err)
	}
	defer manager.Close()

	// Configure seeder options
	options := &seeder.Options{
		Environment: environment,
		Reset:       reset,
		DryRun:      dryRun,
		Verbose:     verbose,
	}

	// Confirm reset operation if requested
	if reset && !dryRun {
		if !confirmDestructiveOperation(fmt.Sprintf("RESET ALL DATA and seed with %s environment", environment)) {
			return fmt.Errorf("seeding cancelled by user")
		}
	}

	// Show seed plan in dry-run mode
	if dryRun {
		fmt.Printf("üîç DRY RUN: Seeding plan for environment '%s':\n", environment)
		
		// Load seed data to show plan
		dataLoader := seeder.NewDataLoader()
		seedData, err := dataLoader.LoadSeedData(environment)
		if err != nil {
			return fmt.Errorf("failed to load seed data for preview: %w", err)
		}
		
		manager.PrintSeedPlan(seedData)
		return nil
	}

	// Run actual seeding (PostgreSQL only for now)
	return manager.SeedPostgres(ctx, options)
}